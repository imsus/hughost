<!doctype html>
<html>
<head>
    <meta http-equiv="content-type" content="text/json; charset=UTF-8">
    <title>Document</title>
</head>
<body>
    
        {"Kind":"page","Pages":null,"Params":{"author":"Imam Susanto","featured":false,"image":"https://www.igvita.com/posts/16/xpassive-attack.png.pagespeed.ic.nKz7sdRzBk.webp","language":"en_US","meta_description":"","meta_title":"","publish_date":""},"Content":"\n\n\u003cp\u003eLet\u0026rsquo;s say we have a client that can initiate a network request for any URL on the web but the response is opaque and cannot be inspected. \u003cstrong\u003eWhat could we learn about the client or the response?\u003c/strong\u003e As it turns out, armed with a bit of patience and rudimentary statistics, \u0026ldquo;a lot\u0026rdquo;.\u003c/p\u003e\n\n\u003cp\u003eFor example, the duration of the fetch is a combination of network time of the request reaching the server, server processing time, and network time of the response. Each and every one of these steps \u0026ldquo;leaks\u0026rdquo; information both about the client and the server.\u003c/p\u003e\n\n\u003cp\u003eFor example, if the total duration is very small (say, \u0026lt;10ms) then we can reasonably intuit that we might be talking to a local cache, which means that the client has previously fetched this resource. Alternatively, if the duration is slightly higher (say, \u0026lt;50ms) then we can reasonably guess that the client is on a low-latency network (e.g. fast 4G or WiFi). We can also append random data to the URL to make it unique and rule out the various HTTP caches along the way. From there, we can try making more requests to the server and observe how the fetch duration changes to infer change in server processing times and/or larger responses being sent to the client.\u003c/p\u003e\n\n\u003cp\u003eIf we\u0026rsquo;re really crafty, we can also use the properties of the network transport like CWND induced roundtrips in TCP (see [TCP Slow Start]), and other quirks of local network configuration, as additional signals to infer properties (e.g. size) of the response—see [TIME], [HEIST] attacks. If the response is compressed and also happens to reflect submitted data, then there is also the possibility of using a \u003ca href=\"see [BREACH]\"\u003ecompression oracle attack\u003c/a\u003e to extract data from the response.\u003c/p\u003e\n\n\u003cp\u003eIn theory, the client could try to stymie such attacks by making all operations take constant time, but realistically that\u0026rsquo;s neither a practical nor an acceptable solution due to the user experience and performance implications of such strategy. Injecting random delays doesn\u0026rsquo;t fare much better, as it carries similar implications.\u003c/p\u003e\n\n\u003ch2 id=\"networking-thermodynamics\"\u003e\u0026ldquo;Networking thermodynamics\u0026rdquo;\u003c/h2\u003e\n\n\u003cp\u003eEach and every step in the fetch process—from the client generating the request and putting on the wire, the network hops to the server, the server processing time, response properties, and the network hops back to the client—\u0026rdquo;leaks\u0026rdquo; information about the properties of the client, network, server, and the response. This is not a bug; it\u0026rsquo;s a fact of life. Borrowing an explanation from our physicist friends: \u003cstrong\u003eputting a system to work amounts to extracting energy from it, which we can then measure and interrogate to learn facts about said system\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eEyes glazing over yet? The practical implication is that \u003cstrong\u003eif the necessary server precautions are missing, the use of the above techniques can reveal private information about you and your relationship to that server\u003c/strong\u003e - e.g. login status, group affiliation, [and more]. This requires a bit more explanation…\u003c/p\u003e\n\n\u003ch2 id=\"the-dangers-of-credentialed-cross-origin-no-cors-requests\"\u003eThe dangers of credentialed cross-origin \u0026ldquo;no-cors\u0026rdquo; requests\u003c/h2\u003e\n\n\u003cp\u003eThe fact that we can use side-channel information, such as the duration of a fetch, to extract information about the response is not, by itself, all that useful. After all, if I give you a URL you can just use your own HTTP client to fetch it and inspect the bytes on the wire. However, what does make it dangerous is if you can co-opt my client (my browser) to make an authenticated request on my behalf and inspect the (opaque) response that contains my private content. Then, even if you can\u0026rsquo;t access the response directly, you can observe any of the aforementioned properties of the fetch and extract private information about my client and the response. Let\u0026rsquo;s make it concrete…\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eI like to visit kittens.com on which I have an account to pin my favorite images:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe authentication mechanism is a login form with all the necessary precautions (CSRF tokens, etc).\u003c/li\u003e\n\u003cli\u003eOnce authenticated, the server sets an HTTP cookie scoped to kittens.com with a private token that is used to authenticate me on future visits.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cp\u003eSomeone else entices me to visit shady.com to view more pictures of kittens\u0026hellip;\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWhile I\u0026rsquo;m indulging in kitten pictures on shady.com, the page issues background requests on my behalf to kittens.com with the goal of attempting to learn something about my status on said site.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003eHow does \u003ccode\u003eshady.com\u003c/code\u003e make a [credentialed request]?\u003c/strong\u003e A simple image element is sufficient:\u003c/p\u003e\n\n\u003cdiv class=\"highlight\" style=\"background: #272822\"\u003e\u003cpre style=\"line-height: 125%\"\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color: #f92672\"\u003eimg\u003c/span\u003e \u003cspan style=\"color: #a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color: #f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #e6db74\"\u003e\u0026quot;https://kittens.com/favorites\u0026quot;\u003c/span\u003e \u003cspan style=\"color: #a6e22e\"\u003ealt\u003c/span\u003e\u003cspan style=\"color: #f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color: #e6db74\"\u003e\u0026quot;Yay authenticated kittens!\u0026quot;\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan style=\"color: #75715e\"\u003e\u0026lt;!-- Image element is not the only mechanism with this behavior, others\u003c/span\u003e\n\u003cspan style=\"color: #75715e\"\u003e\t include script, object, video, etc. Also, there is JavaScript... --\u0026gt;\u003c/span\u003e\n\n\u003cspan style=\"color: #f8f8f2\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color: #f92672\"\u003escript\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan style=\"color: #66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color: #a6e22e\"\u003eimg\u003c/span\u003e \u003cspan style=\"color: #f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color: #66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color: #a6e22e\"\u003eImage\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e();\u003c/span\u003e\n  \u003cspan style=\"color: #a6e22e\"\u003eimg\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e.\u003c/span\u003e\u003cspan style=\"color: #a6e22e\"\u003esrc\u003c/span\u003e \u003cspan style=\"color: #f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color: #e6db74\"\u003e\u0026quot;https://kittens.com/favorites\u0026quot;\u003c/span\u003e\n\u003cspan style=\"color: #f8f8f2\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\"color: #f92672\"\u003escript\u003c/span\u003e\u003cspan style=\"color: #f8f8f2\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe browser processes the image element, initializes a request for \u003ca href=\"https://kittens.com/favorites\"\u003ehttps://kittens.com/favorites\u003c/a\u003e, attaches my HTTP cookies associated with kittens.com, and dispatched the request. The target server (kittens.com) sees a valid authentication cookie and dutifully sends back the HTML response containing my favorite kittens. Of course, the image tag will choke on the HTML and will fire an error callback, but that doesn\u0026rsquo;t matter, because even though we can\u0026rsquo;t inspect the response, we can still learn a lot by observing the timing of the authenticated request-response flow.\u003c/p\u003e\n\n\u003cp\u003eWith the benefit of a few decades of experience under our belt, and if we were rebuilding the web platform from scratch, we probably wouldn\u0026rsquo;t allow such \u0026ldquo;no-cors\u0026rdquo; authenticated requests without [explicit CORS opt-in from the server], just as we do today for XMLHttpRequest and [Fetch API]. Alas, that would be a major breaking change, so that\u0026rsquo;s off the table. However, not all is lost either, because \u003ccode\u003ekittens.com\u003c/code\u003e \u003cstrong\u003ecan deploy additional logic to protect itself, and its users, against such cross-origin attacks\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn this article we\u0026rsquo;re focusing on cross-site timing attacks: why they exist and how to mitigate them. However, note that this is a subclass of the larger Cross-Site Request Forgery (CSRF) type of attacks, which can wreck havoc on your site and your users data. The good news is, the mitigations are the same.\u003c/p\u003e\n\n\u003ch2 id=\"declare-your-cookies-as-same-site\"\u003eDeclare your cookies as \u0026ldquo;same-site\u0026rdquo;\u003c/h2\u003e\n\n\u003cp\u003eThe core issue is that the browser attaches target origin\u0026rsquo;s cookies on \u0026ldquo;no-cors\u0026rdquo; requests regardless of the origin that initiates the request. In theory, the target origin could look at the Referrer header, but the attacker could hide the initiating origin—e.g. via [no-referrer] policy. Similarly, the Origin header is only sent on CORS requests, so that won\u0026rsquo;t help either. However, [SameSite cookies] give us the exact behavior we want:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eHere, we update [RFC6265] with a simple mitigation strategy that allows servers to declare certain cookies as \u0026ldquo;same-site\u0026rdquo;, meaning they should not be attached to \u0026ldquo;cross-site\u0026rdquo; requests…\u003c/p\u003e\n\n\u003cp\u003eNote that the mechanism outlined here is backwards compatible with the existing cookie syntax. Servers may serve these cookies to all user agents; those that do not support the \u0026ldquo;SameSite\u0026rdquo; attribute will simply store a cookie which is attached to all relevant requests, just as they do today.\n\u003cstrong\u003eSameSite cookies have two modes: \u0026ldquo;strict\u0026rdquo; and \u0026ldquo;lax\u0026rdquo;\u003c/strong\u003e. In strict mode, the cookies are not sent in top-level navigations, which offers strong protection but requires some [additional deployment considerations]. In lax mode, cookies are sent for top-level navigations-e.g. navigations initiated by \u003ccode\u003e\u0026lt;a\u0026gt; elements, window.open(), \u0026lt;link rel=prerender\u0026gt;)\u003c/code\u003e, which offers [reasonable protection]. Do read the IETF spec, it provides good guidance.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cdiv class=\"highlight\" style=\"background: #272822\"\u003e\u003cpre style=\"line-height: 125%\"\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan style=\"color: #960050; background-color: #1e0010\"\u003e200 OK HTTP/1.1\u003c/span\u003e\n\u003cspan style=\"color: #960050; background-color: #1e0010\"\u003e...\u003c/span\u003e\n\u003cspan style=\"color: #960050; background-color: #1e0010\"\u003eSet-Cookie: SID=31d4d96e407aad42; SameSite=Strict\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eUsing our example above, if \u003ccode\u003ekittens.com\u003c/code\u003e set the \u003ccode\u003eSameSite\u003c/code\u003e flag on its authentication cookie, then the image request initiated by shady.com would not contain the authentication cookie due to mismatch of the initiating origin and the origin that set the cookie and would result in a generic unauthenticated response—e.g. a redirect to a login page. If you\u0026rsquo;re \u003ccode\u003ekittens.com\u003c/code\u003e, enabling SameSite cookies should be a no-brainer.\u003c/p\u003e\n\n\u003cp\u003eMore generally, \u003cstrong\u003eif your site or service does not intentionally provide cross-origin resources (e.g. embeddable widgets, site plugins, etc.), then you should use SameSite cookies as your default\u003c/strong\u003e.\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eSameSite cookies are [supported in Chrome (since M51)] and Opera 39, and are [under consideration in Firefox]. Let\u0026rsquo;s hope the other browsers will be fast followers. Last but not least, it\u0026rsquo;s worth noting that you also can, as a user, [block third party cookies] in your browser to protect yourself from this type of cross-origin attack.\u003c/p\u003e\n","Summary":"Let\u0026rsquo;s say we have a client that can initiate a network request for any URL on the web but the response is opaque and cannot be inspected. What could we learn about the client or the response? As it turns out, armed with a bit of patience and rudimentary statistics, \u0026ldquo;a lot\u0026rdquo;.\nFor example, the duration of the fetch is a combination of network time of the request reaching the server, server processing time, and network time of the response.","TableOfContents":"\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#networking-thermodynamics\"\u003e\u0026ldquo;Networking thermodynamics\u0026rdquo;\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-dangers-of-credentialed-cross-origin-no-cors-requests\"\u003eThe dangers of credentialed cross-origin \u0026ldquo;no-cors\u0026rdquo; requests\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#declare-your-cookies-as-same-site\"\u003eDeclare your cookies as \u0026ldquo;same-site\u0026rdquo;\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e","Aliases":null,"Images":null,"Videos":null,"Truncated":true,"Draft":false,"Status":"","PublishDate":"0001-01-01T00:00:00Z","ExpiryDate":"0001-01-01T00:00:00Z","Weight":0,"Markup":"markdown","Layout":"json","Frontmatter":null,"Contents":null,"GitInfo":null,"Title":"Stop Cross Site Timing Attacks with Samesite Cookies","Description":"","Keywords":[],"Data":{"Pages":null},"Date":"2017-01-19T23:36:29+07:00","Lastmod":"2017-01-19T23:36:29+07:00","Sitemap":{"ChangeFreq":"","Priority":-1,"Filename":""},"RSSLink":"","URL":"","Permalink":"","Slug":"","Section":""}
    
</body>
</html>